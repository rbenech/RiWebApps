/*jslint devel: true, browser: true, continue: true, windows: false, vars: true, evil: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4 */
/*globals ri, dojo*/ //for jslint

/**-----------------------------------------------------------------------------------------
  wbSmParse.js 
  This handles SM parsing and message distribution for the whiteboard application.
  
  11/16/2011 oer
  ------------------------------------------------------------------------------------------
*/

var ri = ri || {};    //namespace for the ri module

/**module definition*/
ri.smparse = (function () {
  "use strict"; //enable javascript strict mode
  
  //Dependencies:
  //------------------------
  var emitStatus = ri.util.emitStatus;
  
  //Closure local variables:
  //------------------------
  var 
    _smChannel = 'noChannelName',
    _webSkt=null,   //web socket used to communicate with the web server
    
    //Channels used in dojo publish/subscribe messaging to widgets:
    _createChannel  = 'wbCreate', //the dojo widget channel used to signify creation events 
    _commandChannel = 'wbCmd',    //the dojo widget channel used to signify command events
    _widgetChannel  = 'wbWdgt_';  //the dojo widget channel used to signify widget messaging events
  
  //Closure method definitions:
  //---------------------------
    
  /**Called by html button to subscribe to the named rtalk model (e.g. transcript, code, tester, Worksheet, etc.)
   * TODO###: openNewPage on wb_NewPage.html (this would have its own sm channel, subscribe to dojo events on that channel, webSkt needs to dojo publish recvd SMs)
   * */
  var doRtalkSubscribe = function(subscribeTo, subscribeChannel) {
    var elem, msg; //local vars
    
    elem = document.getElementById('subscribeTo');
    if(!subscribeTo) {
      if(elem) { subscribeTo=elem.value; } //get value from html node
    }
    else {
      if(elem) { elem.value=subscribeTo; } //update html to match value used
    }

    elem = document.getElementById('subscribeChannel');
    if(!subscribeChannel) {
      if(elem) { subscribeChannel = elem.value; } //get value from html node
    }
    else {
      if(elem) { elem.value=subscribeChannel; } //update html to match value used
    }
    
    msg = [ 'subscribe', subscribeTo, _smChannel ]; //note: ^subscribe ^view=transcript ^transcript
    ri.riri.sendSm(_webSkt, null, null, subscribeChannel, ri.riri.toRiri(msg, 1)); //convert message to RIRI at separator level 1, then send
  };
  
  /**private: Called for each SM, given the value for sm.MSGS*/
  var handleSmMsg = function(msgs) {
    var subMsgCnt, settings, rtClassName, ndx, s, cmd, val, wname, cmdType, commandName, //local vars
        subscribeTo, subscribeChannel, msgsNdx, msg;

    for(msgsNdx in msgs) { //process each message within the SM
      msg = msgs[msgsNdx];
      if(!msg) { continue; } //empty message
      //console.log(' msg>>'+msg); //debug. show messages being handled ####
      subMsgCnt = msg.length; //number of sub msgs in this msg
      if(subMsgCnt===0) { continue; } //nothing to do
      
      //TODO: convert to just use msg (no settings): anyway not using the map aspect at all, and array would allow parsing via msg.shift() (i.e. read and pop msg[0])
    
      settings = {}; //convert given msg to a map (is this actually useful in javaScript? Don't seem to be using the map aspect...)
      rtClassName=null; //name of class of widget to be created: ListPane, TextPane, GroupPane, Button, etc. 
      for(ndx in msg) {
        s = msg[ndx];
        if(!s) { continue; } //nothing there, skip it
        if(s===msg[0]) { continue; } //skip the first message (handled separately)
        if(s.indexOf) { //if has an indexOf then use it
          cmd = ri.util.getKeyFor(s);
          val = ri.util.getValFor(s);
          if(cmd && cmd==='class') { //Two things: 1) can't put in an entry called class (reserved) and 2) don't need to because going to use it right away 
            rtClassName = val;
          }
          else {
            settings[cmd]=val;
          }
        }
        else  { //assume it's an object not a key/value (HACK ALERT)
          settings.contents=s; //TEST. Need to actually check if it is a 'contents' thing ###
        }
      }

      wname = ri.util.getKeyFor(msg[0]);     //non-lowercased version in case is a widget name instead of a command
      cmdType = wname.toLowerCase(); //lowercased version for use as a command
    
      switch(cmdType) {
        case 'toppane': 
        case 'menu':
          dojo.publish(_createChannel, [[wname, settings]]); 
          continue;
        case 'subpane': 
          dojo.publish(_createChannel, [[rtClassName, settings]]); //rtClassName is defined above
          continue;
        case 'command': 
          commandName = ri.util.getValFor(msg[0]);
          dojo.publish(_commandChannel, [[commandName, settings]]);
          continue;
        case 'createsubscriber': //for now: when get a createSubscriber command, for now just replace the current display with the newly subscribed 
          subscribeChannel = msgs[1];
          subscribeTo = msgs[2];
          doRtalkSubscribe(subscribeTo, subscribeChannel);
          return; //finished with this SM message (assumes that no other commands are included in a 'createSubscriber' message)
        case 'dialog': //NEW ONE. (add this). This should pop up a dialog. Types: prompt, menu, confirm, list
          //Example from Java ri.core.RtPanel:
          //   OrderedMap dialogSettings = smContent.getMsgAsOrderedMap(++ndxMsg, true);
          //   String dialogResponse = smContent.getSubMsgAsStringFrom(++ndxMsg, 0);
          //   handleMsg_Dialog(dialogSettings, dialogResponse);
          break;
        default: //message to an indexed widget
          dojo.publish(_widgetChannel+wname, [settings]);
          continue;  
      }
    }

  };
  
  /**private: Called upon to process each sm that is received*/
  var receiveAnSm = function(sm) {
    if(!sm) { return; } //nothing to do
    if(sm.CHANNEL !== _smChannel) { return; } //skip messages not directed to this application
    if(!sm.MSGS) { return; } //nothing to do
    handleSmMsg(sm.MSGS);
  };
  
  /**Called by html button to update the monitored SM channel.
   * If given a value for the channel it uses that, 
   * otherwise looks for an html element called 'mySmChannel' and uses that*/
  var setSmChannel = function(mySmChannel) {
    if(!mySmChannel) {
      var elem = document.getElementById('mySmChannel');
      if(elem) { mySmChannel=elem.value; }
    }
    _smChannel = mySmChannel;
    emitStatus('SM channel set to "'+_smChannel+'"');
  };
  
  /**Act on received message. It may be a single SM or a whole list of them. 
   * This is called when a message comes in via websocket or ajax
   * */
  var receiveMessages = function(msgs) {
    var ndx, val; //local vars
    if(!msgs) { return; } //nothing to do
    val = ri.riri.convertSmToObject(msgs); //returns a javascript object whether the given message is json or raw sm
    
    //val = eval(msgs); //for json. Note: this causes an error when recv a single json object {}: Unexpected token ':'
    //val = eval('['+msgs+']')[0]; //for json. Hack to fix above issue with single {} received
    
    if(val instanceof Array) { //is a list of sm
      for(ndx in val) {
        receiveAnSm(val[ndx]);
      }
    }
    else { receiveAnSm(val); } //is a single sm
  };
  
  /**private: Finalize (close down) wbSmParse module.*/
  var doFinalize = function() {
    if(typeof ri.websocket.open !== 'undefined') { //if function exists, then close down web sockets
      if(typeof _webSkt !== 'undefined' && !_webSkt) {
        _webSkt = ri.websocket.close(_webSkt); //close any open web sockets
        _webSkt = null;
      }
    }
    if(typeof ri.ajax.enablePolling !== 'undefined') { //if ajax module is loaded, stop any polling going on there
      ri.ajax.enablePolling(false);
    }
  };

  /**Initialize wbSmParse module. Mainly communications: Websockets or Ajax*/
  var doInit = function() {
    var smChannelDiv;  //local vars
        //getGuruTimenow = ri.namespace('util').getGuruTimenow; //ri.util.getGuruTimenow

    _smChannel = 'wb_'+ri.util.getGuruTimenow(true); //make up a unique SM channel name 
    //_smChannel = 'aaa'; //DEBUG
  
    doFinalize(); //close down any previous in case this is a re-init
  
    //Initialize the SM channel display (debug). This is so that user can change the SM channel:
    smChannelDiv = document.getElementById('mySmChannel');
    if(smChannelDiv) {
      smChannelDiv.value=_smChannel;
    }
    
    if(typeof ri.websocket.open !== 'undefined') { //if function exists, then init for web sockets
      
      //_webSkt = ri.websocket.open('ws://localhost:7501/guru/rawsm', receiveMessages); //open and set up the websocket (raw SM messages)
      _webSkt = ri.websocket.open('ws://localhost:7501/guru/sm', receiveMessages); //open and set up the websocket (SM as json)
      
      if(_webSkt) { emitStatus('Websockets enabled'); } //debug
    }
    
    if(!_webSkt && (typeof ri.ajax.enablePolling !== 'undefined') ) { //since that didn't work, switch to ajax (if ri ajax library is available)
      ri.ajax.initializeForPolling(receiveMessages);
      emitStatus('Polling enabled'); //debug
      _webSkt = {}; //define a fake websocket to intercept for ajax
      _webSkt.send = function(msg) { ri.ajax.smPoll(msg); };
      _webSkt.close = function(msg) { ri.ajax.enablePolling(false); };
    }
    if(!_webSkt && !ri.ajax.enablePolling) {
      emitStatus('This app is disabled because: Websockets not available and Ajax not enabled.'); //debug
    }
  };
  
  //Accessors:
  var smChannel = function() { return _smChannel; };
  var webSkt = function() { return _webSkt; };
  var createChannel = function() { return _createChannel; };
  var commandChannel = function() { return _commandChannel; };
  var widgetChannel = function() { return _widgetChannel; };
  

  /*---------------
   *closure return:
   *---------------*/
  return {

    //Public API (list functions here to make them publicly available):
    //-----------------------------------------------------------------
    smChannel: smChannel,
    webSkt: webSkt, 
    createChannel: createChannel,  
    commandChannel: commandChannel, 
    widgetChannel: widgetChannel, 
    
    setSmChannel: setSmChannel,
    doRtalkSubscribe: doRtalkSubscribe,
    receiveMessages: receiveMessages,
    doInit: doInit
  }; //closure return
  
}()); //namespace ri.smparse
