
/**-----------------------------------------------------------------------------------------
  Whiteboard. 
  This application represents a blank slate that is configured by received SM messages.
  The received SM messages indicate what widgets are to be inserted as well as their configuration parameters.

  wbWidgets.js 
  These are the widgets that the whiteboard comprises.
  
  11/16/2011 oer
  ------------------------------------------------------------------------------------------
*/

var _modelSmChannel='none';      //the SM response channel to use when talking back to the model (on the other end of this conversation)
var _widgets = {};               //the map of rt widgets held by this app.
var _createEventsHandle=null;    //publish/subscribe handle for create events
var _commandEventsHandle=null;   //publish/subscribe handle for command events
var _rootDiv="wb_root";          //ID of the DIV of the root Widget Container

/**Sends back an SM with the event item as well as all other selected items (as required for select events).
 * Emits an SM of the form: SM...^event+widget=ID+channel=CHANNELNAME+selection=SELECTION+selection1=SELECTION+selection3=SELECTION...
 * Where ^ + represent RIRI separators.
 * Note: selection values are generally RiStrings, occasionally regular strings.
 * This version does high level assembly of the SM (no RIRI separators)
 * */
function emitSmEvent(widgetId, eventString) {
  emitStatus('Event from widget '+widgetId+'='+eventString); //debug 
  
  var eventMsg = ['event', 'widget='+widgetId, 'channel='+_mySmChannel, 'selection='+eventString]; //assemble the SM message portion
  
  for(var ndx in _widgets) {     //see if any other widgets have selections
    w = _widgets[ndx];
    if(w.getSelected) {          //if this widget defines a getSelected function.
      var sel = w.getSelected(); //returns null if nothing is selected
      if(sel) eventMsg.push('selection'+w.id+'='+sel); //if this widget is participating in the selection event, add to the SM message
    }
  }
  
  //Send out the SM:
  var smDst = '00000000';   //broadcast for now. Eventually should this be directed to _modelSmChannel?
  var smSrc = _mySmChannel; //optional, this can also just be blank 
  sendSm(smDst, smSrc, _modelSmChannel, toRiri(eventMsg)); //convert message to RIRI (at the default separator level of 2), then send it out
}


/**This is the same thing as above but creates the message directly using low level RIRI separators*/
function emitSmEvent_UsingLowLevelSeps(widgetId, eventString) {
  emitStatus('Event from widget '+widgetId+'='+eventString); //debug 
  
  var eventMsg = RIRISEP2 + 'event' + RIRISEP2 + 'widget='+widgetId + RIRISEP2 + 'channel=' + _mySmChannel + RIRISEP2 + 'selection=' + eventString; //assemble the SM message portion
  
  for(var ndx in _widgets) {       //see if any other widgets have selections
    w = _widgets[ndx];
    if(w.getSelected) {            //if this widget defines a getSelected function.
      var sel = w.getSelected();   //returns null if nothing is selected
      if(sel) eventMsg += RIRISEP2 + 'selection'+w.id+'='+sel; //if this widget is participating in the selection event, add to the SM message
    }
  }
  
  //Send out the SM:
  var smDst = '00000000'; //broadcast for now. Eventually should this be directed to _modelSmChannel?
  var smSrc = _mySmChannel; //optional, this can also just be blank 
  sendSm(smDst, smSrc, _modelSmChannel, eventMsg); //send out the message
}

/**Called by widgets when they don't handle a given command. This handles the actions common to all widgets.*/
function baseExecuteCmd(widget, cmd, val) {
  switch(cmd) {

    case 'events': break; //TODO?
    
    case 'frameratio':  //set size: 10;50;100;5: left;right;top;bottom as a percentage of parent window size. 0,0 is bottom left
      widget.frameRatio = getFrameRatioFor(val);
      break;
    
    case 'hscroll': break; //srollbars are handled automatically
    
    case 'identifier': //the id for this widget. Note: If never get an id then it never goes in the widgets list so it cannot be referenced later on.
      widget.id = val;
      _widgets[val]=widget; //add to widgets list
      widget.receiveWidgetEvents = function(settings) { //function to receive widget events from SM. Called by dojo.subscribe
        for(var cmd in settings) //parse through the settings to configure this widget
          widget.executeCmd(cmd.toLowerCase(), settings[cmd]);
      } //function
      widget.unsubscribeFromEvents = function() { //function to cause this widget to unsubscribe from dojo events generated by SM
        if(widget.eventsHandle) {
          dojo.unsubscribe(widget.eventsHandle);
          widget.eventsHandle=null;
          emitStatus('Widget '+widget.id+' unsubscribed from dojo events');
        }
      } //function
      widget.eventsHandle = dojo.subscribe(_widgetChannelWidget+val, widget.receiveWidgetEvents); //register for sm generated events using the given identifier
      break;
    
    case 'name': break; //currently don't do anything with this one
    
    case 'owner':
      var w = _widgets[val]; //set the widget's value for who its parent is 
      widget.parentWidget = w;
      //TODO?: ownerWidget.addWidgetComponent(widget); //needed for javascript? add this widget to component view of the parent 
      break;
    
    case 'vscroll': break; //srollbars are handled automatically
    
    default:
      //TODO: try deleting widget name in smParse when event is generated. If that doesn't work then just use this to ignore the widget name entry here: ###
      if(_widgets[cmd]) ; //ignore. This is a kludge to eliminate warning just because the widget name is always in the list
      else 
        console.log('wbWarning: unrecognized message (id='+widget.id+')'+cmd+'='+val);
      break;
  }
}

/**Make a widget. rtClassType=Button, GroupPane, ListPane, Menu, PanelPane, TextPane, TopPane, TreePane, Worksheet
 * Note: This makes a widget. Note: Must give it a 'executeCmd' method.
 * */
function createWidget(rtClassType) {
  if(!rtClassType) return;
  switch(rtClassType.toLowerCase()) { //using lowercase compares
    
    case "toppane":
      return new function() { //widget class definition
      
        this.executeCmd = function(cmd, val) { //function to parse received messages. returns true if command was handled
          switch(cmd) {
            case 'label': //set the title for whatever is the enclosing Frame or dialog
              document.title = val; //set browser title
              document.getElementByID(_rootDiv).title = val; //set Root Div Title
              //TODO?: send SM to update guru panel button text? (prob. need a hook in servlet to just do this). Without sm's would be CMD_SEND to 255 (no response): "AS,ButtonText=val"
              break;
            case 'model': //the SM response channel to use when talking back to the model (on the other end of this conversation)
              _modelSmChannel = val;
              break;
            case 'type': break; //not used for anything?
            case 'windowsize': break; //TODO? (this is supposed to set the size of the outer window, in characters)
            default: baseExecuteCmd(this, cmd, val); break; //this message not handled here, let parent have a go at it
          }
        } //function
      }; //class definition
      
    case "listpane":
      
      return new function() { //widget class definition
      
        this.setContents = function(val) {
          var elem = document.getElementById(this.id); 
          if(!elem) { //get existing html element or else make a new one
            elem = document.createElement('div');
            elem.setAttribute('id', this.id);
          }
          var elemStyle = makeStyleFromFrameRatio(this.frameRatio); //makes: style="position:absolute; left:20%; top:30%; width:40%; height:50%;"
          elemStyle += ' overflow:auto;"'; //auto or scroll here makes it have scrollbars
          //elemStyle += ' border:solid 1px gray;">'; //add a border. For some reason this doesn't work. Seems to work better to add border to list itself
          elem.setAttribute('style', elemStyle); 
          var selection = 'hello'; //TODO: <--whatever is currently selected from the list is what goes in here (the original RiString value)
          elem.setAttribute('onclick', 'emitSmEvent("'+this.id+'","'+selection+'")' ); //when list is clicked, emit sm event
          var contents = val.contents; //contents is a list of RiStrings: QAAAitem1, QAAAitem2,...
          var a ='<ul style="border: solid 1px gray">'; //html list with border
          //var a ='<ul>'; //html list no border
          for(var ndx in contents) { //fill in the list
            //a+=getRiStringAsLi(contents[ndx]); //this way has list bullets
            a+=getRiStringAsSpan(contents[ndx])+'<br />'; //this gets rid of list bullets
          }
          a+='</ul>';
          elem.innerHTML=a;
          document.getElementByID(_rootDiv).appendChild(elem); //add this element to the page
        } //function
        
        this.getSelected = function() { return null; } //If any elements are selected, it should be returned by this function. This is called anytime an SM event occurs
        
        this.executeCmd = function(cmd, val) { //returns true if command was handled
          switch(cmd) {
            case 'contents': this.setContents(val); break;
            default: baseExecuteCmd(this, cmd, val); break; //this message not handled here, let parent have a go at it
          }
        } //function
      }; //class definition

    case "textpane":
      return new function() { //widget class definition
        this.setContents = function(val) {
          var elem = document.getElementById(this.id); 
          if(!elem) { //get existing html element or else make a new one
            elem = document.createElement('div');
            elem.setAttribute('id', this.id);
          }
          var elemStyle = makeStyleFromFrameRatio(this.frameRatio); //makes: style="position:absolute; left:20%; top:30%; width:40%; height:50%;"
          elemStyle += ' overflow:auto;"'; //auto or scroll here makes it have scrollbars
          //elemStyle += ' border:solid 1px gray;">'; //add a border. For some reason this doesn't work. Seems to work better to add border to list itself
          elem.setAttribute('style', elemStyle);
          var a='<pre style="border: solid 1px gray">'; //text area w/border
          //var a='<pre">'; //text area no border
          a+=val;
          a+='</pre>';  
          elem.innerHTML=a;
          document.getElementByID(_rootDiv).appendChild(elem); //add this element to the page
        } //function
        
        this.getSelected = function() { return 'this is a test'; } //If any text is selected, it should be returned by this function. This is called anytime an SM event occurs
        
        this.executeCmd = function(cmd, val) { //returns true if command was handled
          switch(cmd) {
            case 'contents': this.setContents(val); break;
            case 'clear': case 'showit': case 'append': case 'highlight': case 'insert': case 'position':
              //TODO
              break; 
            default: baseExecuteCmd(this, cmd, val); break; //this message not handled here, let parent have a go at it
          }
        } //function
      }; //class definition

    case "grouppane":
      return new function() { //widget class definition
        this.singleSelect=false; //field
        this.doConfigure = function() { //this is called when widget is ready to be configured (all the settings are in)
          var elem = document.getElementById(this.id);
          if(!elem) { //get existing html element or else make a new one
            elem = document.createElement('div');
            elem.setAttribute('id', this.id);
          }
          var elemStyle = makeStyleFromFrameRatio(this.frameRatio); //makes: style="position:absolute; left:20%; top:30%; width:40%; height:50%;"
          elem.setAttribute('style', elemStyle);
          document.getElementByID(_rootDiv).appendChild(elem); //add this element to the page
          //elem.innerHTML='<div style="border: solid 1px red">group pane</div>'; //DEBUG: make groupPane visible
          delete this.doConfigure; //remove this function after executing it (running it is a one-time occurrence)
        } //function

        this.executeCmd = function(cmd, val) { //returns true if command was handled
          switch(cmd) {
            case 'singleselect': if(val==='true') this.singleSelect=true; break;
            default: baseExecuteCmd(this, cmd, val); break; //this message not handled here, let parent have a go at it
          }
        } //function
      }; //class definition
      
    case "button":
      return new function() { //widget class definition
        this.widgetContents; //this is used as the button name (and value)
        this.isSelected=false; //true if this button is to be initially selected

        this.doConfigure = function() { //this is called when widget is ready to be configured (all the settings are in)
          var parentElem;
          var singleSelect=false;
          if(this.parentWidget) { //if have a parent widget
            parentElem = document.getElementById(this.parentWidget.id); //get id of parent (usu. a group pane)
            if(this.parentWidget.singleSelect) 
              singleSelect = this.parentWidget.singleSelect;
          }
          if(!parentElem) { //i.e. no parent html element.  If don't have a parentElem then just throw it into the top pane?
            parentElem = document.createElement('div');
            parentElem.setAttribute('id', this.id); //???
            document.body.appendChild(parentElem); //add this element to the page
          }
          var nm = this.widgetContents; //riString (or string)
          var nmStr = nm.text ? nm.text : nm; //get string only in case is an riString
          
          var elem = document.getElementById(this.id); //see if this item already exists
          if(!elem) {
            elem = document.createElement('input'); //make an element representing this button
            elem.setAttribute('id', this.id);
            elem.innerHTML = nmStr;
          }

          //Set up the button, like: '<input type="button" onclick="emitSmEvent('nm')" id="'this.id'"  value="'nmStr'"/>'
          if(singleSelect) { //make it a radio button
            elem.setAttribute('type', 'radio');
            elem.setAttribute('name', parentElem.id); //need a common name for radio buttons so use the parent id
          }
          else {             //make it a regular button
            elem.setAttribute('type', 'button');
          }
          elem.setAttribute('onclick', 'emitSmEvent("'+this.id+'","'+nm+'")' ); //when button is clicked, emit sm event (using the original riString value)
          elem.setAttribute('value', nmStr); //displayed button text is the string only version 
          var elemStyle = makeStyleFromFrameRatio(this.frameRatio); //makes: style="position:absolute; left:20%; top:30%; width:40%; height:50%;"
          elem.setAttribute('style', elemStyle);

          parentElem.appendChild(elem); //add this element to parent
          delete this.doConfigure; //remove this function after executing it (running it is a one-time occurrence)
        } //function

        this.getSelected = function() { return null; } //If this button is currently selected, it should return its value (i.e. widgetContents) via this function. This is called anytime an SM event occurs

        this.executeCmd = function(cmd, val) { //returns true if command was handled
          switch(cmd) {
            case 'contents': this.widgetContents = val; break;
            case'selected': if(val==='true') this.isSelected = true; break;
            default: baseExecuteCmd(this, cmd, val); break; //this message not handled here, let parent have a go at it
          }
        } //function
      }; //class definition
 
    case "menu": //###IN WORK
      return new function() { //widget class definition
        this.setContents = function(val) {
          var elem = document.getElementById(this.id); 
          if(!elem) { //get existing html element or else make a new one
            elem = document.createElement('div');
            elem.setAttribute('id', this.id);
            var elemStyle = makeStyleFromFrameRatio(this.frameRatio);
            //elemStyle += ' overflow:auto;"'; //auto or scroll here makes it have scrollbars
            elem.setAttribute('style', elemStyle);
          }
          document.getElementByID(_rootDiv).appendChild(elem); //add this element to the page
        } //function
        
        this.executeCmd = function(cmd, val) { //returns true if command was handled
          switch(cmd) {
            case 'title':
              //TODO
              break;
            case 'value':
              //TODO
              break;
            default: //this message not handled here, let parent have a go at it
              ///###baseExecuteCmd(this, cmd, val); //DEBUG: for now, no menu errors 
              break; 
          }
        } //function
      }; //class definition
      
      default:
        console.log('wbError: Unable to create item of class type: '+rtClassType); //debug
        return null; //no widget definition
  }
}

/**Called when a 'create' event is received.
 * Receives a list: [rtClassName, settings]
 *   rtClassName: e.g. TopPane, Menu, LispPane, TextPane, GroupPane, Button, ...
 *   settings: a collection of key=values to configure widget
 * */
function receiveCreateWidgetEvent(nameAndSettings) {
  var rtClassName = nameAndSettings[0];
  var settings = nameAndSettings[1];
  var widget = createWidget(rtClassName);
  if(widget) //if a widget was created 
    for(var cmd in settings) //configure the widget by going through each of the settings 
      widget.executeCmd(cmd.toLowerCase(), settings[cmd]);
}

/**Called when a 'command' event comes in.
 * Receives a list: [commandName, settings]
 * commandName: e.g. createView, top
 * settings: a collection of key=values
 */
function receiveCommandEvent(nameAndSettings) {
  var commandName = nameAndSettings[0];
  var settings = nameAndSettings[1];

  if(commandName=='createView') { //finalize the layout
    
    for(var ndx in _widgets) { //configure any widgets needing to be configured
      var w = _widgets[ndx];
      if(w.doConfigure) 
        w.doConfigure(); 
    }
    
    for(var ndx in _widgets) { //press any buttons that need a-pressin'
      var w = _widgets[ndx];
      if(w && w.isSelected) { //if it exists and it has an isSelected field
        var id = w.id;
        var elem = document.getElementById(w.id); 
        if(elem) 
          elem.checked = w.isSelected; 
      }
    }
  }
  
  else if(commandName=='top') {} //TODO?: bring this window to the top of the Z-order
}      

/**Initialize wbWidgets module. 
 * Mainly this subscribes to dojo SM events.*/
function doWbWidgetsInit() {
  doWbWidgetsFinalize(); //just in case this is a re-init
  
  //Register to receive widget 'create' messages via dojo publish and subscribe. 
  //These are generally a result of receiving a widget create message over SM.
  _createEventsHandle = dojo.subscribe(_widgetChannelCreate, receiveCreateWidgetEvent);
  
  //Register to receive 'command' messages via dojo publish and subscribe. 
  //These are generally a result of receiving a command message over SM.
  _commandEventsHandle = dojo.subscribe(_widgetChannelCommand, receiveCommandEvent);
}

/**Finalize (close down) wbWidgets module.
 * TODO: call this when need to unsubscribe from dojo SM events*/
function doWbWidgetsFinalize() {
  if(_createEventsHandle) { //unsubscribe from 'widget create' events
    dojo.unsubscribe(_createEventsHandle);
    _createEventsHandle = null;
  }

  if(_commandEventsHandle) {//unsubscribe from 'command' events
    dojo.unsubscribe(_commandEventsHandle);
    _commandEventsHandle=null;
  }
  
  for(ndx in _widgets) { //if there are any widgets and any are subscribed, then unsubscribe them
    if(_widgets[ndx].unsubscribeFromEvents)
      _widgets[ndx].unsubscribeFromEvents();
  }
}
